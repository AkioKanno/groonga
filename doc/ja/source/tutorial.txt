.. highlightlang:: none

チュートリアル
==============

インストール方法
----------------

* MeCabのインストール

形態素単位でトークナイズした全文検索索引を使用したい場合は、
事前にMeCab (http://mecab.sourceforge.net/)をインストールしてください。

* groongaのインストール

http://groonga.org/download/よりtar.gzファイルを取得し、
インストール先の環境にファイルを展開して、 ::

 ./configure --prefix=/usr && make && sudo make install

のように実行することでインストールできます。

prefixは、インストール先を指定するパラメータで、通常/usrを指定します。prefixを指定しない場合には、/usr/localが指定されたものとみなします。

使用方法
--------

groongaは、Cのライブラリとして使用する方法と、groonga実行ファイルを通して使用する方法があります。

本チュートリアルでは、groonga実行ファイルを使用する方法について説明します。

groonga実行ファイル
^^^^^^^^^^^^^^^^^^^

groonga実行ファイルを使って、DBの作成・操作・サーバの起動・サーバへの接続などの操作が行えます。

DBの作成
""""""""

書式 ::

  groonga -n DBパス名

DBパス名には、新しく作成するDBのフルパス名を指定します。
新たなDBを作り、そのまま対話モードに入ります。

実行例::

  % echo '' | groonga -n /var/tmp/hoge.db
  %

DBの操作
""""""""

書式 ::

  groonga DBパス名 [コマンド]

既存のデータベースのフルパス名をDBパス名に指定します。
コマンドを指定すると、実行結果を返します。

コマンドを指定しない場合には、対話モードに入ります。
対話モードでは、標準入力からコマンドを読み込み、順次実行します。

Ctrlキーを押しながらdキーを押すと、対話モードから抜けることができます。

たとえば、statusというコマンドを実行してみましょう。statusコマンドは、groongaの実行状態を返すコマンドです。

実行例::

  % groonga /var/tmp/hoge.db
  > status
  [[0,1269935682.29616,0.000122],{"alloc_count":124,"starttime":1269935680,"uptime":2,"version":"0.1.7-10-g6bf93ba"}]
  > ctrl-d
  %

以上のように、コマンドの実行結果は基本的にjsonという形式で返却されます。jsonの配列の0番目の要素に、エラーコードや実行時間などの情報が入ります。jsonの配列の1番目の様子に、コマンドの実行結果が入ります。

groongaサーバの起動
"""""""""""""""""""

書式 ::

  groonga [-p ポート番号] -d DBパス名

既存のデータベースのフルパス名をDBパス名に指定します。
groongaがデーモンモードで起動し、指定したポート番号でgroongaの専用プロトコルを用いた通信をすることができます。
(ポート番号を省略した場合は10041が使用されます)

実行例::

  % groonga -d /var/tmp/hoge.db
  %

groongaサーバへの接続
"""""""""""""""""""""

書式 ::

  groonga [-p ポート番号] -c [対象ホスト名]

対象ホストで動作しているgroongaサーバに接続します。
対象ホスト名を省略した場合はlocalhostに対して接続し、対象ポート番号を省略した場合は10041ポートに対して接続します。
接続に成功すると対話モードに入り、標準入力からコマンドを読み込んで順次実行します。

実行例::

  % groonga -c
  > status
  [[0,1269936150.9489,6.5e-05],{"alloc_count":125,"starttime":1269935680,"uptime":470,"version":"0.1.7-10-g6bf93ba"}]
  > ctrl-d
  %

コマンド
^^^^^^^^

groonga実行ファイルやgroongaサーバを介して様々なコマンドを実行して、DBを操作することができます。
コマンドは以下の書式のうちいずれかで与えることができます。 ::

 書式1: コマンド名 引数1 引数2..

 書式2: コマンド名 --引数名1 値1 --引数名2 値2,..

 書式3: /d/コマンド名?引数名1=値1&引数名2=値2..

書式1と2は混ぜて使うことができます。
書式3で引数を渡す場合は、コマンド文字列をURLエンコードする必要があります。
詳しくは、:doc:`execfile` を参考にしてください。

主なコマンド
""""""""""""

 :doc:`commands/status`
  groongaプロセスの状態を表示します。
 :doc:`commands/table_list`
  DBに定義されているテーブルのリストを表示します。
 :doc:`commands/column_list`
  テーブルに定義されているカラムのリストを表示します。
 :doc:`commands/table_create`
  DBにテーブルを追加します。
 :doc:`commands/column_create`
  テーブルにカラムを追加します。
 :doc:`commands/select`
  テーブルに含まれるレコードを検索して表示します。
 :doc:`commands/load`
  テーブルにレコードを挿入します。

テーブルの作成
""""""""""""""

:doc:`commands/table_create` コマンドを使用してテーブルを作成します。

groongaでは、多くの場合テーブルを作成する際に主キーが必要となります。また、主キーには型と、その格納方法を指定する必要があります。

型については、本チュートリアルでは触れません。:doc:`type` の項を参照してください。主キーの格納方法によって、主キーでの検索速度や、前方一致検索の可否が決まります。しかし、本チュートリアルでは触れません。

ここでは、ShortText型の主キー値を持ち、主キーの格納方法はHASHである、'Blog'という名前のテーブルを作成します。

実行例::

  > table_create --name Blog --flags TABLE_HASH_KEY --key_type ShortText
  [[0,1268294088.70744,0.098794]]
  >

検索
""""

:doc:`commands/select` コマンドを用いて、テーブルの中身を表示することができます。

実行例::

 > select --table Blog
 [[0,1269854691.80132,0.000106],[[[0],[["_id","UInt32"],["_key","ShortText"]]]]]
 >

selectにテーブル名を指定すると、指定したテーブルの中身を10件表示します。

table_createコマンドで作成したテーブルには、最初から'_id' '_key'という２つのカラムがあります。'_id'はgroongaが自動的に付与するID番号が格納されるカラムです。'_key'は主キーが格納されるカラムです。これらのカラム名を変更することはできません。

カラムの作成
""""""""""""

:doc:`commands/column_create` コマンドを用いて、カラムを作成することができます。

実行例::

 > column_create --table Blog --name title --flags COLUMN_SCALAR --type ShortText
 [[0,1268294203.38404,0.056593]]
 > select --table Blog
 [[0,1269854897.8173,0.000105],[[[0],[["_id","UInt32"],["_key","ShortText"],["title","ShortText"]]]]]

ShortText型の値を持つ、'title'という名前のカラムを'Blog'テーブルに追加しました。COLUMN_SCALARについては、通常のカラムであることを示しています。

全文検索用の語彙テーブル・インデックスカラムの作成
""""""""""""""""""""""""""""""""""""""""""""""""""

このチュートリアルでは、groongaに登録したデータを用いた全文検索を行います。

全文検索を行う場合は、まず語彙テーブルを作成する必要があります。
語彙表テーブルとは、文書の中にある単語が主キーとなるテーブルです。
ここでは、ShortText型の主キー値を持つ、'Terms'という名前のテーブルを作成しました。

実行例::

  > table_create --name Terms --flags TABLE_PAT_KEY|KEY_NORMALIZE --key_type ShortText --default_tokenizer TokenBigram
  [[0,1268294159.76784,0.049841]]
  >

この実行例には、多くのパラメータが指定されています。本チュートリアルでは、これらをすべて理解する必要はありません。以下に簡単な説明を記しますが、読み飛ばしてもらってかまいません。

実行例にある、TABLE_PAT_KEY|KEY_NORMALIZEという値は、主キー値をパトリシア木に格納し、各語彙を正規化して登録することを示しています。

実行例にある、TokenBigramという値は、 語彙表として使用するテーブルは、対象の文書をトークナイズする方式を、default_tokenizerパラメータで与えます。この例ではTokenBigramを指定しています。よって、一般的にN-gramと呼ばれるようなインデックス方式を選択しています。

さて、Blogテーブルのtitleカラムを全文検索の対象としたいとしましょう。その場合には、語彙テーブルにインデックス型のカラムを作成します。

実行例::

 > column_create --table Terms --name blog_title --flags COLUMN_INDEX|WITH_POSITION --type Blog --source title
 [[0,1268294247.01333,0.129917]]
 >

Blogテーブルのtitleカラムを検索対象とする、'blog_title'という名前のインデックス型カラムをTermsテーブルに作成しました。インデックス対象となるテーブルをtypeに、インデックス対象となるカラムをsourceに指定します。

実行例のflagsのCOLUMN_INDEX|WITH_POSITIONという値は、位置情報を格納するインデックス型のカラムであることを示しています。通常の全文検索インデックスでは、COLUMN_INDEX|WITH_POSITIONを指定してください。位置情報を格納する意味については、本チュートリアルでは触れません。

データのロード
""""""""""""""

:doc:`commands/load` コマンドを使用します。

実行例::

 > load --table Blog
 > [{"_key":"http://hoge.com/","title":"hoge"},{"_key":"http://fuga.com/","title":"fuga"}]
 [[0,1268380982.80157,0.002685],2]
 > select Blog
 [[0,1269855382.8395,0.000121],[[[2],[["_id","UInt32"],["_key","ShortText"],["title","ShortText"]],[1,"http://hoge.com/","hoge"],[2,"http://fuga.com/","fuga"]]]]
 >

クエリ文字列の書式
""""""""""""""""""

groongaのクエリ文字列には2種類の書式があります。

selectコマンドのqueryパラメータには、通常の検索エンジンが受け付けるような、簡易な書式でクエリを書くことができます。

実行例 ::

 > select --table Blog --match_columns title --query hoge
 [[0,1268381101.20846,0.000401],[[[1],[["_id","UInt32"],["_key","ShortText"],["title","ShortText"]],[1,"http://hoge.com/","hoge"]]]]
 >

match_columnsパラメータに'title'、queryパラメータに'hoge'という文字列を指定しています。
この場合、titleカラムに対して、'hoge'という文字列で全文検索を行った結果を返します。

selectコマンドのfilterパラメータとscorerパラメータには、
JavaScriptライクな文法で様々な条件を指定することができます。

実行例 ::

 > select --table Blog --filter _id<=2 --scorer _score=rand() --output_columns _id,_key,_score --sortby _score
 [[0,1268381229.56842,0.000219],[[[2],[["_id","UInt32"],["_key","ShortText"],["_score","Int32"]],[2,"http://fuga.com/",846930886],[1,"http://hoge.com/",1804289383]]]]
 > select --table=Blog --filter _id<=2 --scorer _score=rand() --output_columns _id,_key,_score --sortby _score
 [[0,1268381300.12763,0.000164],[[[2],[["_id","UInt32"],["_key","ShortText"],["_score","Int32"]],[1,"http://hoge.com/",1681692777],[2,"http://fuga.com/",1714636915]]]]
 >

filterパラメータには

  _id <= 2

という条件を指定しています。この場合は2件のレコードにヒットします。

scorerパラメータには、

 _score = rand()

という条件を指定しています。各レコードのスコア値にランダムな値を設定しています。

sortbyパラメータには、

 _score

を指定しています。スコア順に昇順にソートすることを意味しています。

このように指定すると、検索する度にランダムな順序で結果を表示することができます。
