
                           groonga チュートリアル (v0.1.1)

■groongaとは?

groongaはLGPL2.1で配布されるオープンソースの全文検索エンジンソフトウェアです。

■動作環境

Linux(x86-64)を主要な対象として開発しています。

■インストール方法

- MeCabのインストール

形態素単位でトークナイズした全文検索索引を使用したい場合は、
事前にMeCab (http://mecab.sourceforge.net/)をインストールしてください。

- groongaのインストール

http://groonga.org/download/よりtar.gzファイルを取得し、
インストール先の環境にファイルを展開して、

 ./configure; make; sudo make install

のように実行することでインストールできます。

■使用方法

groongaは、Cのライブラリとして使用する方法と、
groonga実行ファイルを通して使用する方法があります。
本チュートリアルでは、groonga実行ファイルを使用する方法について説明します。

■groonga実行ファイル

groonga実行ファイルを使って、DBの作成・操作・サーバの起動・サーバへの接続などの
操作が行えます。

- DBの作成

  書式 : groonga -n DBパス名

  DBパス名には、新しく作成するDBのフルパス名を指定します。
  新たなDBを作り、そのまま対話モードに入ります。

  実行例:

    % echo '' | groonga -n /var/tmp/hoge.db
    %

- DBの操作

  書式 : groonga DBパス名 [コマンド]

  既存のデーターベースのフルパス名をDBパス名に指定します。
  コマンドを指定すると、実行結果を返します。
  コマンドを指定しなかった場合は、対話モードに入ります。
  対話モードでは、標準入力からコマンドを読み込み、順次実行します。

  実行例:

    % groonga /var/tmp/hoge.db
    > table_list
    [["id","name","path","flags","domain"]]
    > ctl-d
    %

- groongaサーバの起動

  書式 : groonga [-p ポート番号] -d DBパス名

  既存のデーターベースのフルパス名をDBパス名に指定します。
  指定したポート番号でTCPサービスを開始します。
  (ポート番号を省略した場合は10041が使用されます)
  当該ポートに対して、groongaの専用プロトコルに加えて、
  HTTPやmemcachedバイナリプロトコルが使用できます。

  実行例:

    % groonga -d /var/tmp/hoge.db
    %

- groongaサーバへの接続

  書式 : groonga [-p ポート番号] -c [対象ホスト名]

  対象ホストで動作しているgroongaサーバに接続します。
  対象ホスト名を省略した場合はlocalhostに対して接続します。
  接続に成功すると対話モードに入り、標準入力からコマンドを読み込んで順次実行します。

  実行例:

    % groonga -c
    > table_list
    [["id","name","path","flags","domain"]]
    > ctl-d
    %

■コマンド

groonga実行ファイルやgroongaサーバを介して様々なコマンドを実行して、
DBを操作することができます。
コマンドは以下の二つの書式のいずれかで与えることができます。

 書式1: コマンド名 引数1 引数2..

 書式2: /コマンド名?引数名1=値1&引数名2=値2..

書式2で引数を渡す場合は、コマンド文字列をURLエンコードする必要があります。

- 主なコマンド

 status           : groongaプロセスの状態を表示します。
 table_list       : DBに定義されているテーブルのリストを表示します。
 column_list      : テーブルに定義されているカラムのリストを表示します。
 table_create     : DBにテーブルを追加します。
 column_create    : テーブルにカラムを追加します。
 view_add         : VIEW型のテーブルに要素となるテーブルを追加します。
 select           : テーブルに含まれるレコードを検索して表示します。
 load             : テーブルにレコードを挿入します。
 define_selector  : 検索条件をカスタマイズした新たな検索コマンドを定義します。

■テーブルの作成

table_createコマンドを使用してテーブルを作成します。

 書式: table_create name [flags [key_type [value_type [default_tokenizer]]]]

作成するテーブルの名前をnameに指定します。
flagsには、テーブルの属性を表す以下の数値を指定します。

 0   : 主キー値をハッシュ表で管理するテーブルを作成します。
 1   : 主キー値をパトリシア木で管理するテーブルを作成します。
 3   : 主キーを持たないテーブルを作成します。
 4   : ビューテーブル(複数のテーブルをまとめて操作するための仮想的なテーブル)を作成します。

実行例:

  > table_create Blog 0 ShortText
  true
  >

ShortText型の主キー値を持つ、'Blog'という名前のテーブルを作成しました。

全文検索を行う場合は、語彙表となるテーブルを作成します。

実行例:

  > table_create Terms 129 ShortText Void TokenBigram
  true
  >

ShortText型の主キー値を持つ、'Terms'という名前のテーブルを作成しました。
語彙表となるテーブルはflagsに以下の値を加えることができます。

 64  : 後方一致検索が可能な語彙表を作成します。(パトリシア木型のテーブルに指定可能)
 128 : 主キー値を正規化した上で登録します。(ハッシュ表型かパトリシア木型のテーブルに指定可能)

実行例のflagsの129という値は、主キー値をパトリシア木を使用し、
各語彙を正規化して登録することを示しています。

語彙表として使用するテーブルは、対象の文書をトークナイズする方式を、
default_tokenizerパラメータで与えます。
この例ではバイグラムを指定しています。組み込みトークナイザとして以下が選べます。

 TokenMecab    : 形態素解析(MeCab)で分かち書きした単位を語彙とします。
 TokenDelimit  : 空白で区切った単位を語彙とします。
 TokenUnigram  : 1文字ずつ区切った単位を語彙とします。
 TokenBigram   : 文字バイグラムを語彙とします。
 TokenTrigram  : 文字トライグラムを語彙とします。

■カラムの作成

column_createコマンドを使用してカラムを作成します。

 書式: column_create table name flags type [source]

 カラムを追加するテーブルの名前をtableに指定します。
 作成するカラムの名前をnameに指定します。
 カラムの値が属する型をtypeに指定します。
 flagsには、カラムの属性を表す以下の数値を指定します。

 0   : 単一の値が格納できるカラムを作成します。
 1   : 複数の値の配列を格納できるカラムを作成します。
 2   : インデックス型のカラムを作成します。

実行例:

 > column_create Blog title 0 ShortText
 true
 >

ShortText型の値を持つ、'title'という名前のカラムを'Blog'テーブルに追加しました。

このカラムに登録した文字列に対して全文検索を行う場合は、
語彙表テーブルに対応するインデックス型のカラムを作成します。

実行例:

 > column_create Terms blog_title 514 Blog title
 true
 >

Blogテーブルのtitleカラムを検索対象とする、'blog_title'という名前のインデックス型カラムを
Termsテーブルに作成しました。

インデックス型のカラムを作成した場合は、インデックス対象となるカラムをsourceに指定します。
また、以下の値を加えることでインデックス型カラムに特有の属性を指定できます。

 128 : 段落情報を格納するインデックスを作成します。
 256 : ウェイト情報を格納するインデックスを作成します。
 512 : 位置情報を格納するインデックス(完全転置インデックス)を作成します。

実行例のflagsの514という値は、位置情報を格納するインデックス型のカラムであることを示しています。

■データのロード

loadコマンドを使用します。

 書式: load values table [columns]

レコードを追加するテーブルの名前をtableに指定します。
valuesにはレコードのキーやカラム値をjson形式で表現した文字列を渡します。
有効なjson形式は以下のいずれかです。

 形式1: [[カラム名1, カラム名2,..], [カラム値1, カラム値2,..], [カラム値1, カラム値2,..],..]

 形式2: [{カラム名1: カラム値1, カラム名2: カラム値2}, {カラム名1: カラム値1, カラム名2: カラム値2},..]

columnsパラメータを与えた場合には、形式1の[カラム名1, カラム名2,..]の要素は不要です。

括弧の対応が取れていない文字列を指定した場合は、
括弧が対応するまでvaluesの続きの文字列を標準入力から受け取ります。

実行例:

 > load [{"_key":"http://hoge.com/","title":"hoge"},{"_key":"http://fuga.com/","title":"fuga"}] Blog
 2
 >

■検索

selectコマンドを使用します。

 書式: select table match_column query filter foreach sortby output_columns offset limit

検索対象のテーブルをtableに指定します。
デフォルトの検索対象カラムをmatch_columnに指定します。
query, filterには検索条件を表すクエリ文字列を指定します。
foreachには、検索条件にマッチした全レコードに適用されるクエリ文字列を指定します。
sortbyにはソート条件文字列を指定します。ソート条件文字列は、以下のような形式です。

  [-]カラム名1 [-]カラム名2 [-]カラム名3...

カラム名1の値でソートし、値が同一である場合はカラム名2で、と順次比較を行います。
カラム名の前に - を付加した場合は降順にソートします。(付加しない場合は昇順です)

output_columnsには出力するカラム名のリストを指定します。
offsetとlimitに出力するレコードの範囲(開始行と出力行数)を指定します。
指定範囲のレコードの対象のカラムの値がjson形式で出力されます。

実行例:

 > select Blog
 [2,["_id","_key","title"],[1,"http://hoge.com/","hoge"],[2,"http://fuga.com/","fuga"]]
 >

tableパラメータだけを指定すると、他のパラメータはデフォルト値として解釈され、
先頭10件の全カラムが出力されます。

■クエリ文字列の書式

groongaのクエリ文字列には2種類の書式があります。

selectコマンドのqueryパラメータには簡易な書式が指定できます。

実行例:

 > select Blog title hoge
 [1,["_id","_key","title"],[1,"http://hoge.com/","hoge"]]
 >

match_columnパラメータに'title'、queryパラメータに'hoge'という文字列を指定しています。
この場合、titleカラムに対して、'hoge'という文字列で全文検索を行った結果を返します。

簡易な書式では以下のように指定できます。

  文字列         : 全文検索 (match_columnパラメータに指定したカラムに対して全文検索を実行する)

  "文字列"       : フレーズサーチ(match_columnパラメータに指定したカラムに対してフレーズ検索を実行する)

  カラム名:値    : カラム検索条件(カラム値 == 値)

  カラム名:!値   : カラム検索条件(カラム値 != 値)

  カラム名:<値   : カラム検索条件(カラム値 < 値)

  カラム名:>値   : カラム検索条件(カラム値 > 値)

  カラム名:<=値  : カラム検索条件(カラム値 <= 値)

  カラム名:>=値  : カラム検索条件(カラム値 >= 値)

  カラム名:%値   : カラム検索条件(カラム値 が指定した値を含んでいる)

  a OR b         : aとbとどちらかの条件がマッチする

  a + b          : aとbの両方がマッチする(デフォルト)

  a - b          : aにマッチし、bにはマッチしない

  ( )            : 複数の条件をまとめる

selectコマンドのfilterパラメータとforeachパラメータには、
JavaScript(サブセット)の文法で様々な条件を指定することができます。

実行例:

 > /select?table=Blog&filter=_id<=2&foreach=_score=rand()&output_columns=_id+_key+_score&sortby=_score
 [2,["_id","_key","_score"],[1,"http://hoge.com/",424238335],[2,"http://fuga.com/",719885386]]
 > /select?table=Blog&filter=_id<=2&foreach=_score=rand()&output_columns=_id+_key+_score&sortby=_score
 [2,["_id","_key","_score"],[2,"http://fuga.com/",596516649],[1,"http://hoge.com/",1649760492]]
 >

filterパラメータには

  _id <= 2

という条件を指定しています。この場合は2件のレコードにヒットします。

foreachパラメータには、

 _score = rand()

という条件を指定しています。各レコードのスコア値にランダムな値を設定しています。

sortbyパラメータには、

 _score

を指定しています。スコア順に昇順にソートすることを意味しています。

このように指定すると、検索する度にランダムな順序で結果を表示することができます。


