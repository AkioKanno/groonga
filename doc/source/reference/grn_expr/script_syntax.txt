.. -*- rst -*-

.. highlightlang:: none

.. groonga-command
.. database: reference_grn_expr_script_syntax

Script syntax
=============

Script syntax is a syntax to specify complex search condition. It is
similar to ECMAScript. For example, ``_key == "book"`` means that
groonga searches records that ``_key`` value is ``"book"``. All values
are string in :doc:`query_syntax` but its own type in script
syntax. For example, ``"book"`` is string, ``1`` is integer,
``TokenBigram`` is the object whose name is ``TokenBigram`` and so on.

Script syntax doesn't support full ECMAScript syntax. For example,
script syntax doesn't support statement such as ``if`` control
statement, ``for`` iteration statement and variable definition
statement. Function definion is not supported too. But script syntax
addes the original additional operators.  They are described after
ECMAScript syntax is described.

Sample data
-----------

Here are a schema definition and sample data to show usage.

.. groonga-command
.. include:: ../../example/reference/grn_expr/query_syntax/setup.log
.. table_create Entries TABLE_PAT_KEY ShortText
.. column_create Entries content COLUMN_SCALAR Text
.. column_create Entries n_likes COLUMN_SCALAR UInt32
.. table_create Terms TABLE_PAT_KEY|KEY_NORMALIZE ShortText --default_tokenizer TokenBigram
.. column_create Terms entries_key_index COLUMN_INDEX|WITH_POSITION Entries _key
.. column_create Terms entries_content_index COLUMN_INDEX|WITH_POSITION Entries content
.. load --table Entries
.. [
.. {"_key":    "The first post!",
..  "content": "Welcome! This is my first post!",
..  "n_likes": 5},
.. {"_key":    "Groonga",
..  "content": "I started to use groonga. It's very fast!",
..  "n_likes": 10},
.. {"_key":    "Mroonga",
..  "content": "I also started to use mroonga. It's also very fast! Really fast!",
..  "n_likes": 15},
.. {"_key":    "Good-bye Senna",
..  "content": "I migrated all Senna system!",
..  "n_likes": 3},
.. {"_key":    "Good-bye Tritonn",
..  "content": "I also migrated all Tritonn system!",
..  "n_likes": 3}
.. ]

There is a table, ``Entries``, for blog entries. An entry has title,
content and the number of likes for the entry. Title is key of
``Entries``. Content is value of ``Entries.content`` column. The
number of likes is value of ``Entries.n_likes`` column.

``Entries._key`` column and ``Entries.content`` column are indexed
using ``TokenBigram`` tokenizer. So both ``Entries._key`` and
``Entries.content`` are fulltext search ready.

OK. The schema and data for examples are ready.

Literals
--------

Integer
^^^^^^^

Integer literal is sequence of ``0`` to ``9`` such as
``1234567890``. ``+`` or ``-`` can be prepended as sign such as
``+29`` and ``-29``. Integer literal must be decimal. Octal notation,
hex and so on can't be used.

The maximum value of integer literal is ``9223372036854775807`` (``= 2
** 63 - 1``). The minimum value of integer literal is
``-9223372036854775808`` (``= -(2 ** 63)``).

Float
^^^^^

Float literal is sequence of ``0`` to ``9``, ``.`` and ``0`` to ``9``
such as ``3.14``. ``+`` or ``-`` can be prepended as sign such as
``+3.14`` and ``-3.14``. ``${RADIX}e${EXPORNENTIAL}`` and
``${RADIX}E${EXPORNENTIAL}`` formats are also supported. For example,
``314e-2`` is the same as ``3.14``.

String
^^^^^^

String literal is ``"..."``. You need to escape ``"`` in literal by
prepending ``\\'' such as ``\"``. For example, ``"Say \"Hello!\".`` is
a literal for ``Say "Hello!".`` string.

String encoding must be the same as encoding of database. The default
encoding is UTF-8. It can be changed by ``--with-default-encoding``
configure option, ``--encodiong`` :doc:`/executables/groonga` option
and so on.

Boolean
^^^^^^^

Boolean literal is ``true`` and ``false``. ``true`` means true and
``false`` means false.

Null
^^^^

Null literal is ``null``. Groonga doesn't support null value but null
literal is supported.

Time
^^^^

TODO: ...

.. note::

   This is the groonga original notation.

Time literal doesn't exit. String time notation, integer time notation,
float time notation are used for it.

Geo point
^^^^^^^^^

TODO: ...

.. note::

   This is the groonga original notation.

Geo point literal doesn't exist. String geo point notation is used for
it.

Array
^^^^^

TODO: ...

Object literal
^^^^^^^^^^^^^^

TODO: ...

Control syntaxes
----------------

Script syntax doesn't support statement. So you cannot use control
statement such as ``if``. You can only use ``A ? B : C`` expression as
control syntax.

``A ? B : C`` returns ``B`` if ``A`` is true, ``C`` otherwise.

TODO: example

Grouping
--------

Its syntax is ``(...)``. ``...`` is space separated expression list.

``(...)`` groups one ore more expressions and they can be
processed as an expression. ``a b OR c`` means that ``a`` and ``b``
are matched or ``c`` is matched. ``a (b OR c)`` means that ``a`` and
one of ``b`` and ``c`` are matched.

TODO: example

Function call
-------------

Its syntax is ``name(arugment1, argument2, ...)``.

TODO: description

TODO: example

Basic operators
---------------

Groonga supports operators defined in ECMAScript.

Multiplication operator
^^^^^^^^^^^^^^^^^^^^^^^

Its syntax is ``number1 * number2``.

The operator multiplies ``number1`` and ``number2`` and returns the result.

TODO: example

Addition operator
^^^^^^^^^^^^^^^^^

Its syntax is ``number1 + number2``.

The operator adds ``number1`` and ``number2`` and returns the result.

TODO: example

Addition operator
^^^^^^^^^^^^^^^^^

Its syntax is ``number1 + number2``.

The operator adds ``number1`` and ``number2`` and returns the result.

TODO: example

Subtraction operator
^^^^^^^^^^^^^^^^^^^^

Its syntax is ``number1 - number2``.

The operator subtracts ``number2`` from ``number1`` and returns the result.

TODO: example

Division operator
^^^^^^^^^^^^^^^^^

Its syntax is ``number1 / number2`` and ``number % number2``.

The operator divides ``number2`` by ``number1``. ``/`` returns the
quotient of result. ``%`` returns the remainder of result.

TODO: example

Logical NOT operator
^^^^^^^^^^^^^^^^^^^^

Its syntax is ``!condition``.

The operator inverts boolean value of ``condition``.

TODO: example

Bitwise NOT operator
^^^^^^^^^^^^^^^^^^^^

Its syntax is ``~number``.

The operator returns bitwise NOT of ``number``.

TODO: example

Bitwise AND operator
^^^^^^^^^^^^^^^^^^^^

Its syntax is ``number1 & number2``.

The operator returns bitwise AND between ``number1`` and ``number2``.

TODO: example

Logical AND operator
^^^^^^^^^^^^^^^^^^^^

Its syntax is ``condition1 && condition2``.

The operator returns true if both of ``condition1`` and
``condition2`` are true, false otherwise.

TODO: example

Logical NOT operator
^^^^^^^^^^^^^^^^^^^^

Its syntax is ``condition1 &! condition2``.

The operator returns true if ``condition1`` is true but
``condition2`` is false, false otherwise.

TODO: example

Left shift operator
^^^^^^^^^^^^^^^^^^^

Its syntax is ``number1 << number2``.

The operator performs a bitwise left shift operation on ``number1`` by
``number2``.

TODO: example

Signed right shift operator
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Its syntax is ``number1 >> number2``.

The operator shifts bits of ``number1`` to right by ``number2``. The sign
of the result is the same as ``number1``.

TODO: example

Unsigned right shift operator
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Its syntax is ``number1 >>> number2``.

The operator shifts bits of ``number1`` to right by ``number2``. The
sign of the result is always positive.

TODO: example

Bitwise OR operator
^^^^^^^^^^^^^^^^^^^

Its syntax is ``number1 | number2``.

The operator returns bitwise OR between ``number1`` and ``number2``.

TODO: example

Bitwise XOR operator
^^^^^^^^^^^^^^^^^^^^

Its syntax is ``number1 ^ number2``.

The operator returns bitwise XOR between ``number1`` and ``number2``.

TODO: example

Logical OR operator
^^^^^^^^^^^^^^^^^^^

Its syntax is ``condition1 || condition2``.

The operator returns true if either ``condition1`` or ``condition2`` is
true, false otherwise.

TODO: example

Equal operator
^^^^^^^^^^^^^^

Its syntax is ``object1 == object2``.

The operator returns true if ``object1`` equals to ``object2``, false
otherwise.

TODO: example

Not equal operator
^^^^^^^^^^^^^^^^^^

Its syntax is ``object1 != object2``.

The operator returns true if ``object1`` does not equal to
``object2``, false otherwise.

TODO: example

Assignment operators
--------------------

TODO: ...

Original operators
------------------

Script syntax adds the original binary opearators to ECMAScript
syntax. They operate search specific operations. They are starts with
``@`` or ``*``.

.. _match-oeprator:

Match operator
^^^^^^^^^^^^^^

Its syntax is ``column @ value``.

The operator searches ``value`` by inverted index of ``column``.
Normally, full text search is operated but tag search can be operated.
Because tag search is also implemented by inverted index.

:doc:`query_syntax` uses this operator by default.

Here is a simple exmaple.

.. groonga-command
.. include:: ../../example/reference/grn_expr/script_syntax/simple_match_operator.log
.. select Entries --filter 'content @ "fast"' --output_columns content

The expression matches records that contain a word ``fast`` in
``content`` column value.

``content`` column is the default match column.

.. _prefix-search-operator:

Prefix search operator
^^^^^^^^^^^^^^^^^^^^^^

Its syntax is ``column @^ value``.

The operator does prefix search with ``value``. Prefix search searches
records that contain a word that starts with ``value``.

You can use fast prefix search against a column. The column must be
indexed and index table must be patricia trie table
(``TABLE_PAT_KEY``) or double array trie table
(``TABLE_DAT_KEY``). You can also use fast prefix search against
``_key`` pseudo column of patricia trie table or double array trie
table. You don't need to index ``_key``.

Prefix search can be used with other table types but it causes all
records scan. It's not problem for small records but it spends more
time for large records.

Here is a simple exmaple.

.. groonga-command
.. include:: ../../example/reference/grn_expr/script_syntax/simple_prefix_search_operator.log
.. select Entries --filter '_key @^ "Goo"' --output_columns _key

The expression matches records that contain a word that starts with
``Goo`` in ``_key`` pseudo column value. ``Good-bye Senna`` and
``Good-bye Tritonn`` are matched with the expression.

.. _suffix-search-operator:

Suffix search operator
^^^^^^^^^^^^^^^^^^^^^^

Its syntax is ``column @$ value``.

This operator does suffix search with ``value``. Suffix search
searches records that contain a word that ends with ``value``.

You can use fast suffix search against a column. The column must be
indexed and index table must be patricia trie table
(``TABLE_PAT_KEY``) with ``KEY_WITH_SIS`` flag. You can also use fast
suffix search against ``_key`` pseudo column of patricia trie table
(``TABLE_PAT_KEY``) with ``KEY_WITH_SIS`` flag. You don't need to
index ``_key``. We recommended that you use index column based fast
suffix search instead of ``_key`` based fast suffix search. ``_key``
based fast suffix search returns automatically registered
substrings. (TODO: write document about suffix search and link to it
from here.)

.. note::

   Fast suffix search can be used only for non-ASCII characters such
   as hiragana in Japanese. You cannot use fast suffix search for
   ASCII character.

Suffix search can be used with other table types or patricia trie
table without ``KEY_WITH_SIS`` flag but it causes all records
scan. It's not problem for small records but it spends more time for
large records.

Here is a simple exmaple. It uses fast suffix search for hiragana in
Japanese that is one of non-ASCII characters.

.. groonga-command
.. include:: ../../example/reference/grn_expr/script_syntax/simple_suffix_search_operator.log
.. table_create Titles TABLE_NO_KEY
.. column_create Titles content COLUMN_SCALAR ShortText
.. table_create SuffixSearchTerms TABLE_PAT_KEY|KEY_WITH_SIS ShortText
.. column_create SuffixSearchTerms index COLUMN_INDEX Titles content
.. load --table Titles
.. [
.. {"content": "ぐるんが"},
.. {"content": "むるんが"},
.. {"content": "せな"},
.. {"content": "とりとん"}
.. ]
.. select Titles --query 'content:$んが'

The expression matches records that have value that ends with ``んが``
in ``content`` column value. ``ぐるんが`` and ``むるんが`` are matched
with the expression.

.. _near-search-operator:

Near search operator
^^^^^^^^^^^^^^^^^^^^

Its syntax is ``column *N "word1 word2 ..."``.

The operator does near search with words ``word1 word2 ...``. Near
search searches records that contain the words and the words are
appeared in the near distance. Near distance is always ``10`` for
now. The unit of near distance is number of character in N-gram family
tokenizers and number of words in morphological analysis family
tokenizers.

Note that an index column for full text search must be defined for
``column``.

Here is a simple exmaple.

.. groonga-command
.. include:: ../../example/reference/grn_expr/script_syntax/simple_near_search_operator.log
.. select Entries --filter 'content *N "I fast"'      --output_columns content
.. select Entries --filter 'content *N "I Really"'    --output_columns content
.. select Entries --filter 'content *N "also Really"' --output_columns content

The first expression matches records that contain ``I`` and ``fast``
and the near distance of those words are in 10 words. So the record
that its content is ``I also st arted to use mroonga. Its' also very
fast! ...`` is matched. The number of words between ``I`` and ``fast``
is just 10.

The second expression matches records that contain ``I`` and
``Really`` and the near distance of those words are in 10 words. So
the record that its content is ``I also st arted to use mroonga. Its'
also very fast! Really fast!`` is not matched. The number of words between
``I`` and ``Really`` is 11.

The third expression matches records that contain ``also`` and
``Really`` and the near distance of those words are in 10 words. So
the record that its content is ``I also st arted to use mroonga. Its'
also very fast! Really fast!`` is matched. The number of words between
``also`` and ``Really`` is 10.

.. _similar-search-operator:

Similar search
^^^^^^^^^^^^^^

Its syntax is ``column *S "document"``.

The operator does similar search with document ``document``. Similar
search searches records that have similar content to
``document``.

Note that an index column for full text search must be defined for
``column``.

Here is a simple exmaple.

.. groonga-command
.. include:: ../../example/reference/grn_expr/script_syntax/simple_similar_search_operator.log
.. select Entries --filter 'content *S "I migrated all Solr system!"' --output_columns content

The expression matches records that have similar content to ``I
migrated all Solr system!``. In this case, records that have ``I
migrated all XXX system!`` content are matched.

.. _term-extract-operator:

Term extract operator
^^^^^^^^^^^^^^^^^^^^^

Its syntax is ``_key *T "document"``.

The operator extracts terms from ``document``. Terms must be
registered as keys of the table of ``_key``.

Note that the table must be patricia trie (``TABLE_PAT_KEY``) or
double array trie (``TABLE_DAT_KEY``). You can't use hash table
(``TABLE_HASH_KEY``) and array (``TABLE_NO_KEY``) becuase they don't
support longest common prefix search. Longest common prefix search is
used to implement the operator.

Here is a simple exmaple.

.. groonga-command
.. include:: ../../example/reference/grn_expr/script_syntax/simple_term_extract_operator.log
.. table_create Words TABLE_PAT_KEY|KEY_NORMALIZE ShortText
.. load --table Words
.. [
.. {"_key": "groonga"},
.. {"_key": "mroonga"},
.. {"_key": "Senna"},
.. {"_key": "Tritonn"}
.. ]
.. select Words --filter '_key *T "Groonga is the successor project to Senna."' --output_columns _key

The expression extrcts terms that included in document ``Groonga is
the successor project to Senna.``. In this case, ``KEY_NORMALIZE``
flag is specified to ``Words``. So ``Groonga`` can be extracted even
if it is loaded as ``groonga`` into ``Words``. All of extracted terms
are also normalized.
